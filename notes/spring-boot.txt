### üß† SPRING BOOT TOPICS ‚Äì COMPLETE & SEQUENCED (INDUSTRY STANDARD)

---

#### 1Ô∏è‚É£ Spring Boot Basics

* Spring Framework vs Spring Boot vs Spring MVC
* Why Spring Boot? (convention over configuration)
* Project structure & modules
  -> 1. Layer-Based 2. Feature-Based
* Spring Initializr (UI + CLI)
* Main class (`@SpringBootApplication`)
* SpringApplication lifecycle
* Embedded servers (Tomcat, Jetty, Undertow)
* Auto-configuration: how it works under the hood
* Starter dependencies (`spring-boot-starter-*`)
* DevTools (auto-reload, LiveReload)
* Banner customization

---

#### 2Ô∏è‚É£ Build Tools

* Maven basics: lifecycle phases, `pom.xml`, dependencies
* Gradle basics: `build.gradle`, Groovy vs Kotlin DSL
* Maven multi-module projects
* Plugin usage: Surefire, Shade, Spring Boot plugin
* Build profiles in Maven and Gradle
* Versioning and Dependency Management

---

#### 3Ô∏è‚É£ Configuration Management

* `application.properties` vs `application.yml`
* Profile-specific properties & activation (`@Profile`, `spring.profiles.active`)
* External configuration sources (env variables, cmd line, jar params, config server)
* Environment abstraction: `Environment`, `ApplicationContext`
* Property injection (`@Value`, `@ConfigurationProperties`, `@PropertySource`)

---

#### 4Ô∏è‚É£ Dependency Injection & Bean Management

* Stereotype annotations: `@Component`, `@Service`, `@Repository`, `@Controller`
* DI: `@Autowired` (constructor, field, setter), optional injection
* Bean scopes (`@Scope`)
* Lazy init: `@Lazy`
* Primary beans: `@Primary`, `@Qualifier`
* `@Bean`, `@Configuration`, `@Import`, `@ImportResource`
* Bean lifecycle: `@PostConstruct`, `@PreDestroy`, InitializingBean, DisposableBean
* Conditional annotations: `@ConditionalOnMissingBean`, `@ConditionalOnProperty`, etc.

---

#### 5Ô∏è‚É£ Web Layer (REST APIs)

* `@RestController`, `@RequestMapping`, `@GetMapping`, `@PostMapping`, etc.
* `@RequestBody`, `@RequestParam`, `@PathVariable`, `@RequestHeader`, `@CookieValue`
* Content negotiation: JSON, XML, YAML
* `ResponseEntity` and response customization
* API versioning (URI, Header, Param, MIME type)
* Exception handling:

  * `@ControllerAdvice`, `@ExceptionHandler`
  * Global error structure
  * Custom exception classes
* Input validation:

  * Bean Validation API (JSR 380): `@NotNull`, `@Size`, etc.
  * `@Valid`, `@Validated`, custom validators

---

#### 6Ô∏è‚É£ Data Access (JPA, JDBC, Repositories)

* Spring Data JPA: `CrudRepository`, `JpaRepository`, `PagingAndSortingRepository`
* Defining entities: `@Entity`, `@Id`, `@GeneratedValue`, `@Table`
* Relationships: `@OneToMany`, `@ManyToOne`, etc.
* Fetch strategies: LAZY vs EAGER
* Cascade types
* Custom queries: JPQL, Native SQL, `@Query`, `@Modifying`
* Projections: Interface-based & DTO-based
* Pagination & Sorting: `Page`, `Pageable`, `Sort`
* Transactions: `@Transactional`, rollbackFor
* Spring JDBC: `JdbcTemplate`, `NamedParameterJdbcTemplate`
* Connection pooling (HikariCP)

---

#### 7Ô∏è‚É£ Database Versioning

* Flyway: SQL-based version control
* Liquibase: XML/YAML/JSON/SQL migrations

---

#### 8Ô∏è‚É£ API Enhancements

* DTOs and ModelMapper / MapStruct
* Custom response wrapper (standardized API responses)
* Caching: `@Cacheable`, `@CachePut`, `@CacheEvict`, `@EnableCaching`
* Redis integration

---

#### 9Ô∏è‚É£ Security (Spring Security)

* Spring Security filter chain
* AuthenticationManager, ProviderManager
* Password encoding: BCrypt, Argon2
* Form-based login, Basic Auth
* Role-based authorization (`hasRole`, `hasAuthority`)
* Method-level security: `@Secured`, `@PreAuthorize`, `@PostAuthorize`
* CSRF protection, CORS config
* Stateless auth with JWT: Filter, Token Provider, UserDetailsService
* OAuth2: Google/GitHub login, scopes
* Session management, remember-me

---

#### üîü Testing

* Unit testing: JUnit 5, Mockito
* Integration testing: `@SpringBootTest`, `@DataJpaTest`, `@WebMvcTest`
* Test slicing
* MockMvc
* Embedded database testing: H2
* TestContainers

---

#### 1Ô∏è‚É£1Ô∏è‚É£ DevTools, Monitoring & Observability

* Logging: SLF4J, Logback, JSON logs
* Spring Boot Actuator: health, metrics, custom endpoints
* Micrometer
* Prometheus + Grafana integration
* ELK (Elasticsearch, Logstash, Kibana)
* Distributed tracing: Sleuth + Zipkin

---

#### 1Ô∏è‚É£2Ô∏è‚É£ Asynchronous & Scheduling

* `@Async`, `@EnableAsync`
* Future/CompletableFuture
* `@Scheduled`, cron expressions
* Thread pool configuration

---

#### 1Ô∏è‚É£3Ô∏è‚É£ Messaging & Integration

* Kafka: `@KafkaListener`, `KafkaTemplate`
* RabbitMQ (AMQP): `@RabbitListener`, queues, exchanges
* WebSocket + STOMP + SockJS
* Email sending: JavaMailSender
* SMS/Push Notifications: Twilio, Firebase

---

#### 1Ô∏è‚É£4Ô∏è‚É£ Documentation

* Swagger/OpenAPI (springdoc-openapi)
* Grouped APIs, security schemes
* Postman collection generation

---

#### 1Ô∏è‚É£5Ô∏è‚É£ Production-Readiness & DevOps

* Dockerizing Spring Boot (multi-stage Dockerfile)
* Docker Compose
* GitHub Actions / Jenkins CI/CD
* Kubernetes deployment:

  * Deployment YAMLs, Service, Ingress
  * ConfigMaps, Secrets, readiness/liveness probes
* Helm charts
* Spring Boot with AWS (EC2, ECS, Elastic Beanstalk)
* Spring Boot with GCP/Azure (optional)
* Spring Cloud Config Server
* Vault integration (secrets management)

---

#### 1Ô∏è‚É£6Ô∏è‚É£ Microservices & Cloud Native

* Spring Cloud (Netflix OSS)
* Eureka Server (Service Discovery)
* Spring Cloud Gateway / Zuul (API Gateway)
* Feign Clients (REST client abstraction)
* Load Balancing: Ribbon / Spring Cloud LoadBalancer
* Circuit Breakers: Resilience4j
* Centralized config: Config Server
* Service tracing: Sleuth + Zipkin

---

#### 1Ô∏è‚É£7Ô∏è‚É£ Internal Mechanics & Advanced Topics

* `spring.factories` & custom starter creation
* ApplicationContext lifecycle
* Event publishing: `ApplicationEvent`, `@EventListener`
* Servlet Filters and Handler Interceptors
* Lifecycle hooks: `CommandLineRunner`, `ApplicationRunner`
* Conditional annotations (`@ConditionalOnClass`, etc.)

---

#### 1Ô∏è‚É£8Ô∏è‚É£ Advanced Architectures (Optional Deep Dive)

* HATEOAS
* GraphQL with Spring Boot
* gRPC
* Multi-tenant architecture (schema & database per tenant)
* Reactive Programming (Spring WebFlux: Mono, Flux)
* Functional-style bean definitions
* Kotlin support (Coroutines, DSL)

---






NOW, LET's DEEP-DIVE


‚úÖ 1Ô∏è‚É£ Spring Boot Basics
  | Topic                                   | What It Is                                                                                                        | Note                                                                                                                            |
  | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
  | **Spring vs Spring Boot vs Spring MVC** | Spring = Core Framework, Spring MVC = Web Layer (Controllers, Views), Spring Boot = Opinionated + Auto-config     | *"Spring Boot reduces boilerplate using autoconfig & starters. Spring MVC is part of Spring Boot if you build a web app."*      |
  | **Why Spring Boot**                     | Convention over configuration, auto setup                                                                         | *"It minimizes XML config, has embedded servers, and production-ready defaults."*                                               |
  | **Project Structure**                   | Packages: controller, service, repo, model, config                                                                | *"I follow layered architecture for testability & clarity."*                                                                    |
  | **Spring Initializr**                   | UI/CLI tool to generate starter project                                                                           | *"It bootstraps a new Spring Boot project with starters & build files."*                                                        |
  | **@SpringBootApplication**              | Combines `@Configuration`, `@EnableAutoConfiguration`, `@ComponentScan`                                           | *"It marks the main entry point and kicks off Spring Boot."*                                                                    |
  | **SpringApplication Lifecycle**         | Handles app startup: init ‚Üí context load ‚Üí run ‚Üí shutdown                                                         | *"Used for customizing app startup & programmatic control."*                                                                    |
  | **Embedded Servers**                    | Tomcat (default), Jetty, Undertow                                                                                 | *"Spring Boot uses embedded servers = easy deployment, no WARs."*                                                               |
  | **Auto-Configuration**                  | Uses `@Conditional*` to configure beans if certain conditions match                                               | *"Spring Boot checks classpath, env props, and creates beans auto-magically."*                                                  |
  | **Starters**                            | Pre-packaged dependencies: e.g., `spring-boot-starter-web`                                                        | *"Each starter includes everything needed for a specific task (web, data, security)."*                                          |
  | **DevTools**                            | Auto-restart, LiveReload, dev-only settings                                                                       | *"Speeds up dev feedback loop. Not meant for production."*                                                                      |
  | **Banner Customization**                | Replace default startup banner (ASCII art)                                                                        | *"Purely cosmetic, fun way to personalize projects."*                                                                           |

  Spring Boot is Opinionated:
    Spring Boot is an opinionated extension of Spring that auto-configures your application and allows you to build standalone, production-ready Java applications with minimal boilerplate.
    Opinionated means: Spring Boot makes decisions for you ‚Äî it chooses sensible defaults so you don't have to configure everything manually.

    Eg: When we add:
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    Without you writing a single config:
      Boot auto-configures Tomcat as the embedded server
      Enables Spring MVC
      Adds Jackson for JSON conversion
      Sets up a DispatcherServlet
      Configures default error pages, and more

    That‚Äôs opinionated behavior:
      It assumes **what you probably
    
  Conversion over configuration meaning:
    It means: If you follow the expected conventions, Spring Boot will automatically configure things for you ‚Äî no need to write boilerplate XML or annotations.
    üß† Simple Translation:
      ‚ÄúDo it the usual way, and I got you.‚Äù ‚Äì Spring Boot, probably
      Instead of asking you to specify every little detail (like the location of config files, bean names, view resolvers, etc.), Spring Boot assumes defaults and just works ‚Äî as long as you stick to its conventions.
      | Thing                 | Convention                                                                | If You Do This                                              | You Get‚Ä¶                             |
      | --------------------- | ------------------------------------------------------------------------- | ----------------------------------------------------------- | ------------------------------------ |
      | üìÅ Project structure  | `src/main/java`, `src/main/resources`                                     | Place files here                                            | Auto-detection of config & resources |
      | üîç Component scanning | Classes in the same or sub-package of `@SpringBootApplication`            | No need to specify base packages manually                   |                                      |
      | üõ† Properties         | Use `application.properties` or `application.yml` in `resources/`         | Spring Boot auto-loads them                                 |                                      |
      | üíæ DB Config          | Add `spring-boot-starter-data-jpa` + JDBC URL in `application.properties` | Boot auto-configures Hibernate, DataSource, etc.            |                                      |
      | üñ•Ô∏è Web App            | Add `spring-boot-starter-web`                                             | Auto-configures Spring MVC, DispatcherServlet, JSON support |                                      |

      You follow the rules ‚Üí Spring Boot rewards you with less boilerplate and faster development.
  SpringApplication Lifecycle:
    It‚Äôs the sequence of steps that Spring Boot goes through when starting up your application ‚Äî from bootstrapping to bean creation to running your logic.
    üß† Happens When You Run:
      @SpringBootApplication
      public class TrendKartApp {
        public static void main(String[] args) {
          SpringApplication.run(TrendKartApp.class, args);
        }
      }

      That single line triggers a full-on spring-powered orchestration show.
        | üî¢ Step                            | üîß What Happens                                                                                            | üß† Key Concepts                                                  |
        | ---------------------------------- | --------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
        | **1. Bootstrap**                   | `SpringApplication` instance is created                                                                   | You can customize startup (set banners, profiles, add listeners) |
        | **2. Environment Preparation**     | Reads `application.properties` / `.yml`, system properties, env vars                                      | Initializes `ConfigurableEnvironment`                            |
        | **3. Listeners Triggered**         | Fires early lifecycle events like `ApplicationStartingEvent`, `ApplicationEnvironmentPreparedEvent`, etc. | Use `ApplicationListener` to hook into early lifecycle           |
        | **4. ApplicationContext Creation** | Sets up `AnnotationConfigServletWebServerApplicationContext` (web) or regular context (CLI apps)          | Core IoC container is created                                    |
        | **5. Bean Definitions Loaded**     | Scans for `@Component`, `@Service`, `@Repository`, `@Bean`, etc.                                          | Component scanning + dependency injection                        |
        | **6. Auto-Configuration**          | Applies default configs using `@EnableAutoConfiguration` and classpath conditions                         | Uses `@ConditionalOnClass`, `@ConditionalOnMissingBean`, etc.    |
        | **7. Context Refreshed**           | ApplicationContext is refreshed ‚Üí beans fully initialized ‚Üí lifecycle methods triggered                   | `@PostConstruct`, `InitializingBean`                             |
        | **8. Runners Triggered**           | Runs any `CommandLineRunner` or `ApplicationRunner` beans (if defined)                                    | Good for DB seeding, startup checks                              |
        | **9. Application Ready**           | App is fully started and ready to handle requests                                                         | Embedded server running (Tomcat/Jetty)                           |
        | **10. Graceful Shutdown**          | Runs shutdown hooks when app stops or crashes                                                             | `@PreDestroy`, close DBs, cleanup resources                      |

      Concepts:
        Bootstrap:
          - to start something by itself, from scratch, without external help.
          - Bootstrapping means the initial process of setting up and launching a system ‚Äî especially where components initialize themselves and each other.
          - Note: SpringApplication is the class that bootstraps everything.

        ApplicationListener:
          - is how you hook into Spring Boot‚Äôs lifecycle events, especially the early stages before the context is even fully created.
          - Perfect for:
            Logging startup stages
            Customizing environment before it's locked
            Firing up secrets loading or config decrypting
            Debugging weird startup issues
          
          You can register a class that listens to specific lifecycle events like:
          | Event Class                           | When It Fires                                                  |
          | ------------------------------------- | -------------------------------------------------------------- |
          | `ApplicationStartingEvent`            | üöÄ Right after app starts bootstrapping (before anything else) |
          | `ApplicationEnvironmentPreparedEvent` | üì¶ After environment is loaded, but context not yet created    |
          | `ApplicationPreparedEvent`            | üß† After the context is created, but before beans are loaded   |
          | `ApplicationStartedEvent`             | ‚úÖ After the context is refreshed                               |
          | `ApplicationReadyEvent`               | üéâ App is fully ready to serve                                 |
          | `ApplicationFailedEvent`              | üí• If app startup fails due to an exception                    |

          | Use Case                       | Listener Type                                    |
          | ------------------------------ | ------------------------------------------------ |
          | Load secrets before beans init | `ApplicationEnvironmentPreparedEvent`            |
          | Initialize a metrics reporter  | `ApplicationStartedEvent`                        |
          | Custom shutdown log            | `ContextClosedEvent` or `ApplicationFailedEvent` |
          | Validate external config early | `ApplicationPreparedEvent`                       |
        
        ApplicationContext Creation:
          - ApplicationContext:
            - is spring's central container. The heart of the framework.
            - Holds and manages all the beans, their life-cycles, dependencies, configs, even listeners in an application
            - It‚Äôs an interface that extends BeanFactory and adds extra features:
                Dependency Injection (DI)
                Bean lifecycle management
                Internationalization
                Application events
                Environment config access
                Web integration (in WebApplicationContext)

            üí° What Happens During ApplicationContext Creation?
              Spring Boot detects the app type (Web, CLI, Reactive).
              Based on that, it creates an appropriate context:
                AnnotationConfigServletWebServerApplicationContext for Web
                AnnotationConfigApplicationContext for non-Web (CLI, Batch)
              It prepares the context ‚Äî adds:
                Bean definition readers
                Environment configs
                Message sources
                Event multicaster
              Beans start getting registered but not initialized yet
        Embedded Server:
          - An embedded server means the web server runs inside your app, not outside of it.
          - Spring Boot uses embedded servers like Tomcat so the application can run as a self-contained .jar without deploying to an external server. It simplifies development and is ideal for microservices and cloud deployments.
          - Eg. Tomcat
          | Benefit                        | Why It Rocks                                          |
          | ------------------------------ | ----------------------------------------------------- |
          | ‚úÖ **No WAR needed**           | Just `java -jar` your fat `.jar` file                 |
          | üöÄ **Quick to develop & test** | Spin up instantly with embedded server                |
          | ‚öôÔ∏è **Easier CI/CD**            | No app server setup ‚Äî the server lives *with* the app |
          | üåç **Microservice friendly**   | Perfect for containerization, Docker, K8s, etc.       |
        Auto-Configuration:
          - Spring Boot uses @EnableAutoConfiguration to load many pre-defined config classes, and applies them conditionally using 
          annotations like @ConditionalOnClass, @ConditionalOnProperty, and @ConditionalOnMissingBean from classes in META-INF/spring.factories
          - Role of @Conditional* Annotations:
            - These annotations decide whether or not to apply an auto-configuration, based on certain conditions.
            | Annotation                     | Fires if‚Ä¶                                                 |
            | ------------------------------ | --------------------------------------------------------- |
            | `@ConditionalOnClass(X.class)` | Class `X` is on the classpath                             |
            | `@ConditionalOnMissingBean`    | A bean of that type is NOT already defined                |
            | `@ConditionalOnProperty`       | A specific property (like `spring.datasource.url`) exists |
            | `@ConditionalOnWebApplication` | Only if this is a web application                         |
            | `@ConditionalOnExpression`     | If a SpEL (Spring Expression Language) evaluates to true  |
            | `@ConditionalOnJava`           | Checks Java version                                       |
          - To see what is being configured. We can run the application with --debug
    

  Spring Core: What You Should Know Before Coding

    ---

    ### 1Ô∏è‚É£ What Is a **Bean** in Spring?

    A **Bean** is just an object managed by the Spring **IoC (Inversion of Control) Container**.
    * When you annotate something with `@Component`, `@Service`, `@Repository`, or define it via `@Bean` in config, Spring:
      * Instantiates it
      * Injects its dependencies
      * Manages its lifecycle

    It‚Äôs like saying:
    > ‚ÄúHey Spring, you own this object now. I‚Äôll just *ask you* for it when I need it.‚Äù

    ---

    ### 2Ô∏è‚É£ Why Are Beans **Singleton by Default**?
    Because Spring wants to save memory and avoid creating multiple copies of the same service.
    ```java
    @Service
    public class UserService {}
    ```

    This is a **singleton** by default, meaning:
    * One and only one instance of `UserService` is created and reused across the app.
    > Why? Because services are usually **stateless**, so one copy is enough.

    ---

    ### 3Ô∏è‚É£ Spring Bean Scopes

    | Scope         | Meaning                                         |
    | ------------- | ----------------------------------------------- |
    | `singleton`   | One shared instance (default)                   |
    | `prototype`   | New instance *every time* you `@Autowired` it   |
    | `request`     | New bean per HTTP request (only in web context) |
    | `session`     | New bean per session                            |
    | `application` | Shared across app context (like singleton)      |

    Use prototype if the bean holds **state** and shouldn't be shared.

    Singleton V/s Application Scope:
    | Scope         | Applies In                | Lifetime                                 | What It Means                                                        |
    | ------------- | ------------------------- | ---------------------------------------- | -------------------------------------------------------------------- |
    | `singleton`   | **Default Spring scope**  | One bean instance *per Spring container* | Same instance reused everywhere                                      |
    | `application` | **Web applications only** | One bean instance *per ServletContext*   | Tied to the app lifecycle in a servlet container (Tomcat/Jetty/etc.) |

    singleton works anywhere, not just in web apps. It‚Äôs the general default.
    application is useful in multi-app environments, where you're running multiple web apps under the same server (like two WAR files on a Tomcat server), and you want the bean to exist once per app, but not globally.

    ---

    ### 4Ô∏è‚É£ How Are Beans Created?

    Via one of the following:

    | Method        | Example Annotation                                     |
    | ------------- | ------------------------------------------------------ |
    | Auto-detected | `@Component`, `@Service`, `@Repository`, `@Controller` |
    | Manual        | `@Bean` in a `@Configuration` class                    |
    | Conditional   | `@ConditionalOnProperty`, `@Profile`, etc.             |

    ---

    ### 5Ô∏è‚É£ Dependency Injection (DI)

    **Instead of creating objects with `new`,** you let Spring *inject* them for you.

    Example:

    ```java
    @Service
    public class ProductService {
        private final ProductRepository repo;

        @Autowired
        public ProductService(ProductRepository repo) {
            this.repo = repo;
        }
    }
    ```

    > You‚Äôre not in control anymore ‚Äî Spring is. Hence, **Inversion of Control**.

    ---

    ### 6Ô∏è‚É£ Bean Lifecycle (Simplified)

    1. Instantiate (`new`)
    2. Inject dependencies
    3. Run any init methods (`@PostConstruct`)
    4. Use the bean
    5. Destroy bean on shutdown (`@PreDestroy`)

    ---

    ### 7Ô∏è‚É£ Bonus: Annotations You Should Know NOW

    | Annotation        | Purpose                                      |
    | ----------------- | -------------------------------------------- |
    | `@Component`      | Generic bean                                 |
    | `@Service`        | Business logic layer                         |
    | `@Repository`     | DAO layer with exception translation         |
    | `@Controller`     | Handles web requests (MVC)                   |
    | `@RestController` | `@Controller` + `@ResponseBody`              |
    | `@Autowired`      | Inject dependency (constructor is preferred) |
    | `@Qualifier`      | If multiple beans of same type               |
    | `@Bean`           | Manual bean registration                     |
    | `@Configuration`  | Class that defines `@Bean`s                  |

---

    ### 2Ô∏è‚É£ **Dependency Injection (DI) & IoC**

    | Concept  | What It Means                                                                           |
    | -------- | --------------------------------------------------------------------------------------- |
    | **IoC**  | You don‚Äôt create objects with `new`, Spring gives you the object (control is inverted). |
    | **DI**   | You ‚Äúinject‚Äù dependencies into classes automatically.                                   |
    | **How?** | Through `@Autowired`, constructor injection (preferred), or setter injection.           |

    ---

    ### 3Ô∏è‚É£ **Spring Configuration**

    | Annotation        | Purpose                                                                   |
    | ----------------- | ------------------------------------------------------------------------- |
    | `@Configuration`  | Class that contains one or more `@Bean` methods (manual bean definitions) |
    | `@Bean`           | Create and manage a bean manually                                         |
    | `@Value`          | Inject properties from application.yml/properties                         |
    | `@PropertySource` | Load custom properties file                                               |

    ---

    ### 4Ô∏è‚É£ **Component Scanning**

    ```java
    @SpringBootApplication
    public class App {}
    ```

    This covers:

    * `@ComponentScan`: Finds `@Component`-annotated beans in the package
    * `@EnableAutoConfiguration`: Auto-configures stuff based on dependencies
    * `@Configuration`: This class also defines beans and config

    > `@SpringBootApplication` is just a combination of all 3 above.

    ---

    ### 5Ô∏è‚É£ **Spring Boot Application Lifecycle**

    | Phase       | What Happens                                      |
    | ----------- | ------------------------------------------------- |
    | App starts  | Spring Boot initializes context, creates beans    |
    | Beans wired | DI and component scan kicks in                    |
    | App runs    | All `@PostConstruct`, listeners, schedulers, etc. |
    | App ends    | `@PreDestroy`, cleanup, context destroyed         |

    ---

    ### 8Ô∏è‚É£ **Logging**

    ```yaml
    logging:
      level:
        root: INFO
        com.trendkart: DEBUG
    ```

    You control what gets printed, where, and how.

    ---

  ### 9Ô∏è‚É£ **Spring Boot Starters**

  > These are **bundled dependency packs** like:

  * `spring-boot-starter-web` ‚Üí Web + REST APIs
  * `spring-boot-starter-data-jpa` ‚Üí Hibernate + DB
  * `spring-boot-starter-security` ‚Üí Auth
  * `spring-boot-starter-validation` ‚Üí Bean validation
  * `spring-boot-starter-actuator` ‚Üí Monitoring

  ---

  ### üîü **Validation & Exception Handling**

  * `@Valid`, `@NotNull`, `@Email`, `@Min`, etc.
  * `@ControllerAdvice` + `@ExceptionHandler` = Global error handling

  ---

  ### üß™ Bonus Concepts Worth Knowing:

  | Topic                          | Why It Matters                                    |
  | ------------------------------ | ------------------------------------------------- |
  | `@RestControllerAdvice`        | Cleaner global exception handling                 |
  | `@PostConstruct`/`@PreDestroy` | Hook into bean lifecycle                          |
  | Lombok                         | Avoid boilerplate (`@Data`, `@Builder`, etc.)     |
  | Actuator                       | Monitor endpoints: `/actuator/health`, `/metrics` |
  | Swagger/OpenAPI                | Auto API documentation                            |
  | Scheduling                     | `@Scheduled(fixedRate = ...)` for jobs            |

  ---

  ## üî• TL;DR Checklist:

  ‚úÖ Bean Basics + Scopes
  ‚úÖ Dependency Injection
  ‚úÖ Application Lifecycle
  ‚úÖ Configuration + Profiles
  ‚úÖ Logging
  ‚úÖ Starters
  ‚úÖ Property Injection
  ‚úÖ Exception Handling
  ‚úÖ Component Scanning
  ‚úÖ Validation

  You master this? You‚Äôre basically **Spring Boot Elite Tier.**

---

  AOP - Aspect Oriented Programming
    - Aspect Oriented programmming is a way of structuring the code which helps in separating the cross-cutting
      concerns(Logging, Security, Transactions) from the main logic.
    - cross-cutting means that it cuts across multiple layers / modules
    - Without AOP -> It will cause boilerplate code
    - with AOP -> We extract these common concerns and handle them outside the core business logic, in separate "aspects"
    - Core concepts of AOP:
        - Aspect -> the cross cutting logic -> like the logging, security etc.
        - Advice -> what action to take and when to perform it -> before, after, around method
        - Join Point -> A point in code execution -> Like a method call.
        - Point Cut -> A set of join points, filters when advice should run
        - Weaving -> Injecting the Aspects into the actual code, done using the AOP Frameworks.
    - üîß Where is AOP used in Industry?
        | Use Case         | Example in Real Projects                                                |
        | ---------------- | ----------------------------------------------------------------------- |
        | **Logging**      | Log every incoming request and response                                 |
        | **Security**     | Check if user is authorized before method call                          |
        | **Transactions** | Rollback or commit database transactions (Spring does this via AOP)     |
        | **Performance**  | Measure method execution time                                           |
        | **Monitoring**   | Inject metrics collection logic (Datadog, Prometheus, etc.)             |
        | **Validation**   | Enforce input rules without touching every controller or service method |



‚úÖ 2Ô∏è‚É£ Build Tools
  üîß **What Are Build Tools?**
  > **Build tools** automate the process of:
    * **Compiling code**
    * **Resolving dependencies**
    * **Running tests**
    * **Packaging your app** into `.jar` or `.war`
    * And optionally: **deploying it**

  ‚öîÔ∏è **Maven vs Gradle ‚Äì Quick Comparison**
  | Feature                  | **Maven** üíé                       | **Gradle** ‚ö°                             |
  | ------------------------ | ---------------------------------- | ---------------------------------------- |
  | **Build file**           | `pom.xml` (XML format)             | `build.gradle` (Groovy or Kotlin)        |
  | **Configuration style**  | Declarative                        | Declarative + Scriptable                 |
  | **Speed**                | Slower (no build cache by default) | Faster (build cache + incremental build) |
  | **Readability**          | Verbose but predictable            | Concise but can get tricky               |
  | **Community**            | Massive in Java ecosystem          | Growing, especially in Android           |
  | **Used in Spring Boot?** | ‚úÖ Default, fully supported         | ‚úÖ Also supported                         |

  ‚úÖ For **Spring Boot**, both are solid.
    ‚ÄúI‚Äôve mainly used **Maven**, since it‚Äôs stable, widely adopted, and well-integrated with Spring Boot‚Äôs plugins.‚Äù

  üß± Now, A Little More on Maven:
    üì¶ 1. **Maven Lifecycle Phases**
      | Phase      | What It Does                       |
      | ---------- | ---------------------------------- |
      | `validate` | Check if project structure is fine |
      | `compile`  | Compile source code                |
      | `test`     | Run unit tests                     |
      | `package`  | Bundle into `.jar` or `.war`       |
      | `verify`   | Run additional checks              |
      | `install`  | Install `.jar` into local repo     |
      | `deploy`   | Push `.jar` to remote repo         |

    üìú 2. **`pom.xml` Structure**
      ```xml
      <project>
        <groupId>com.trendkart</groupId>
        <artifactId>trendkart-core</artifactId>
        <version>1.0.0</version>
        <dependencies>
          <!-- Spring Boot starter, DB drivers, etc. -->
        </dependencies>
      </project>
      ```

    üîå 3. **Popular Maven Plugins**
      | Plugin                     | Purpose                         |
      | -------------------------- | ------------------------------- |
      | `maven-surefire-plugin`    | Run unit tests                  |
      | `spring-boot-maven-plugin` | Run and package Spring Boot app |
      | `maven-shade-plugin`       | Build fat/uber jars             |
      | `jacoco-maven-plugin`      | Generate test coverage reports  |

    üåé 4. **Build Profiles**
      Define different environments: `dev`, `test`, `prod`
      ```xml
      <profiles>
        <profile>
          <id>dev</id>
          <properties>
            <env>dev</env>
          </properties>
        </profile>
      </profiles>
      ```

  üß† 5. **Dependency Management**
    * Handles **transitive dependencies**
    * Use `<dependencyManagement>` to **pin versions** across modules
    * Uses **local repo** (`~/.m2/repository`) and remote ones like Maven Central

‚úÖ 3Ô∏è‚É£ Configuration Management
  | **Concept**                                   | **Quick Summary**                                                                    |
  | --------------------------------------------- | ------------------------------------------------------------------------------------ |
  | `application.properties` vs `application.yml` | Two formats for config; `.properties` = key=value, `.yml` = cleaner hierarchy.       |
  | Profile-specific properties                   | Create `application-dev.yml`, `application-prod.yml`, etc. for env-specific configs. |
  | `spring.profiles.active`                      | Used to activate a specific profile (`dev`, `prod`, etc.) via config or CLI.         |
  | `@Profile` annotation                         | Restrict beans/configs to specific profiles (`@Profile("dev")`).                     |
  | External config sources                       | Configs can come from env vars, CLI args, JAR params, or Spring Cloud Config.        |
  | `Environment`, `ApplicationContext`           | Interfaces to access env-specific properties and app context.                        |
  | `@Value`                                      | Inject individual values like `@Value("${server.port}")`.                            |
  | `@ConfigurationProperties`                    | Binds a group of properties into a POJO for cleaner structure.                       |
  | `@PropertySource`                             | Load extra property files manually into context.                                     |

  üß† @Profile Annotation:
    @Configuration
    @Profile("dev") //  Only loads a bean when spring.profiles.active=dev
    public class DevConfig {
        @Bean
        public DataSource devDataSource() {
            return new HikariDataSource(); // dev DB config here
        }
    }
    
    üåé External config sources
      From CLI: java -jar app.jar --server.port=9090

    üå°Ô∏è Environment / ApplicationContext:
      @Component
      public class EnvExample {
          @Autowired
          private Environment env;

          public void printPort() {
              System.out.println("Port: " + env.getProperty("server.port"));
          }
      }

      üì¶ @ConfigurationProperties
        1. YAML/Properties
          my:
            app:
              name: TrendKart
              version: 1.0
        2. POJO
          @Component
          @ConfigurationProperties(prefix = "my.app")
          public class AppConfig {
              private String name;
              private String version;
              // getters + setters
          }
        üìÅ @PropertySource - ‚úÖ Load non-default property files (not application.yml/properties)
            @Configuration
            @PropertySource("classpath:extra-config.properties")
            public class ExtraConfig {
                @Value("${extra.prop}")
                private String value;
            }
        | ‚úÖ Use This                 | ‚ùì Why It's Best                                                                                                  |
        | -------------------------- | ---------------------------------------------------------------------------------------------------------------- |
        | `@ConfigurationProperties` | üî• **Cleanest**, best for binding **groups** of related settings (DB, cache, app config, etc.)                   |
        | `@Value`                   | ‚úÖ Use only for **simple one-off values** (like version, port, feature flag).                                     |
        | `Environment`              | ‚úÖ Great when you need to **dynamically fetch** or access unknown keys at runtime.                                |
        | `@Profile`                 | üî• **Must-have** for loading dev/stage/prod-specific beans/configs cleanly.                                      |
        | `External Configs`         | üî• Crucial for prod! Keep secrets/env-specific stuff **out of code**. Use env vars, CLI, or Spring Cloud Config. |
        | `@PropertySource`          | ‚ö†Ô∏è Use **only if** you have extra property files (like `sms-config.properties` etc.)                             |


  - Notes are in application.yml file
  About some of the configurations we are going to do in application.yml:
    1. Hikari Connection Pool
      - But what is Connection Pool?
        - A connection pool is a cache of pre-created database connections that the app uses instead of


‚úÖ PROJECT IMPLEMENTATION NOTES:

  1. Initialising the Project:
    - Done Using Spring Initializer
        Group: com.trend-kart: Organisation name (in reverse domain style)
              Used to uniquely identify your project. In Maven/Gradle world, this helps avoid clashes with other libraries.
        Artifact: trendkart-backend -> Actual Project or Module name. It becomes the JAR file name when built (trendkart-backend-1.0.jar).
        Name: Just a human-friendly name for project, hows up in build tools or Spring Boot startup logs.
        Description: Shows up in API documentation
        Package:  base Java package under which your classes will live.
        Dependencies:
          Spring Web - Build web, including RESTful, applications using Spring MVC. Uses Apache Tomcat as the default embedded container.
          Spring JPA - Persists Data in SQL based stores using Spring Data and Hibernate
            JPA - It is a specification in Java to manage relational data using ORM(Object Relational Mapping). It is just the rules.
            Hibernate - It is the actual working libraries -> Eg: Hibernate, EclipseLink, OpenJPA

  2. PostgreSQL Database setup and the tables:
      Lombok: A library that helps in annotations
        @Data: @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor

  2. Event listeners
    - Event Listeners can be thought of as event subscribers
    - We publish an event like AuditLogEvent
    - Spring scans all the @EventListener and @TransactionEventListener methods
      - The methods which are annotated with these are registered using ApplicationMulticaster
      - If anyone is listening to the event then the method is triggered
  4. Asynchronous & Scheduling
     * Async and EnableAsync annotations
        - It runs a method asynchronously in a separate Thread, without blocking the main Thread
        - Only works if the async method is called from a different bean
        - Use cases:
          | Use Case                       | Why Use `@Async`?                            |
          | ------------------------------ | -------------------------------------------- |
          | Send order confirmation emails | Don‚Äôt make users wait for SMTP               |
          | Save audit logs (like you did) | Non-blocking, faster                         |
          | Push notifications             | Firebase/APNs take time ‚Äî fire in background |
          | Update product feed in Redis   | Async refresh of data                        |
          | Webhook calls                  | Hit 3rd party endpoints without waiting      |
      * Scheduled and EnableScheduling -> Will discuss later
      * Thread Pool Configuration
        - A thread pool is a group of background threads that our app can re-use to perfom some task asynchronously or on schedule,
          instead of creating new threads everytime, which is a costly operation. (We can say that threads are on standby)
        - Spring uses thread pool executor in background to handle all this.
            If you don‚Äôt configure anything:
              You get a default one-thread pool üêå
              All async tasks run on a single thread
              Everything feels slow or blocked
            
            | Task                   | Thread Pool Benefit                     |
            | ---------------------- | --------------------------------------- |
            | Audit logging (async)  | Don‚Äôt block user flow                   |
            | Email sending          | Async queue of mail tasks               |
            | Cache refresh to Redis | Multiple threads can update in parallel |
            | Analytics logging      | Fire-and-forget w/o holding up UX       |
            | Cron-based cleanup     | Don‚Äôt mess with main request threads    |
          
          corePoolSize - corePoolSize is the minimum number of threads that the pool will keep alive ‚Äî even if they‚Äôre idle.
            Why it shouldn't be large:
              Memory (stack ~512KB to 1MB)
              CPU time (context switching, scheduling)
              Resources from the JVM and OS -> Management will be an overhead
          Standard formula to find the number of threads that we should keep:
              Number of CPU cores * (1 + Wait Time / Compute Time)
          corePoolSize = 10‚Äì50	‚úÖ Reasonable for most backend apps
          To print the current thread: Thread.currentThread.getName()
  
  5. Exception Handling in Java
      - Exception: Something that interrrupts the normal flow of any process
      - Errors: Are generaaly caused due to resources unavailability. 

      ## ‚úÖ **Standard Industry Practice for Error Handling in Java Spring Boot**
      In **most real-world backend systems** (including at places like Amazon, Netflix, etc.), error handling is done in a way that‚Äôs:

      ### üîπ Centralized
        All exceptions go to one place (using `@RestControllerAdvice`), so responses are consistent.

      ### üîπ Layered
        * Validation errors (`@Valid`, `@NotNull`, etc.) are caught and mapped cleanly.
        * Business logic errors use custom exceptions (but **only when necessary**).
        * DB constraint violations like **duplicate keys**, **FK errors**, etc., are caught via standard Spring exceptions like `DataIntegrityViolationException`.

      ### üîπ Message Mapping
        Constraint/DB errors are handled by **parsing the root cause**, and **mapping common constraint names to human-readable messages**.
        **NOT** by making a custom class per error.

      ---

      ## üì¶ Here's the Standard Stack in Most Mid to Large Backends:
        | Error Type                      | Exception Type                    | Handling Strategy                      |
        | ------------------------------- | --------------------------------- | -------------------------------------- |
        | Validation (e.g. empty name)    | `MethodArgumentNotValidException` | Field-level error messages returned    |
        | Bad request/illegal params      | `IllegalArgumentException`        | Return `400 Bad Request`               |
        | Duplicate key, constraint error | `DataIntegrityViolationException` | Map constraint name to message         |
        | Business rule violation         | `CustomBusinessException`         | Only when it‚Äôs **real** business logic |
        | Unhandled internal error        | `Exception`                       | Generic `500 Internal Server Error`    |
        | Auth issues                     | `AccessDeniedException`, etc.     | Handled via Spring Security filters    |

      ---

      ### üß™ Example in Real Products (Amazon-style apps):
        **Constraint errors** like `users_email_key` ‚Üí ‚ÄúEmail already exists.‚Äù
        are **handled by parsing `PSQLException` message** dynamically and mapping the `constraint name` to a **friendly error message** in the response.

      ---

      ## üîß BONUS: Error Response Format (Standard Practice)
        Most APIs respond with something like:

        ```json
        {
          "timestamp": "2025-06-25T18:30:00Z",
          "status": 409,
          "error": "Conflict",
          "message": "Email already exists.",
          "path": "/api/users"
        }
        ```
        You can create a reusable response structure (DTO) for this.

      ---

      ## ‚úÖ So in short:

      > ‚ú® **We should avoid creating a class per error.**
      > ‚úÖ The *standard* is: Use centralized `@RestControllerAdvice`, catch specific known Spring exceptions (like `DataIntegrityViolationException`), and parse meaningful messages dynamically.

      So, In my App, 
        The goal is to have a centralized error handling, which will handle different type of error
        and will also be scalable to add other 
      
      Advices:
        Advices are reusable pieces of code that can be run at specific points in the app, like before or after method calls or on exceptions.
        @RestControllerAdvice = @ControllerAdvice + @ResponseBody
          -> Special kind of advice that watches over the rest controller.
          -> Gets triggered only on exceptions.
          -> Returns JSONs as reponses. 
        | Term                        | Meaning                                                |
        | --------------------------- | ------------------------------------------------------ |
        | **Advice**                  | Reusable logic applied around method calls             |
        | **`@RestControllerAdvice`** | Global JSON exception handler for all REST controllers |
        | **Why use it?**             | To centralize and simplify error handling              |
      
      MethodArgumentNotValidException:
        - Exception will be thrown when a method argument which is annotated with @Valid or @Validated fails validation
        - @Valid Annotation:
            - Will check if the argument violates any validation which may have been defined using 'Java Bean Validation' in the class
              Some annotations of the Java Bean class:
                @NotBlank, @Size, @Min, @Max, @Email, etc. 
        - @Valid v/s @Validated
          | Annotation   | Package                                               | Used On                          | Groups Support | Use Case                                                                 |
          | ------------ | ----------------------------------------------------- | -------------------------------- | -------------- | ------------------------------------------------------------------------ |
          | `@Valid`     | `jakarta.validation.Valid`                            | Parameters, fields               | ‚ùå No           | Simple bean validation (basic annotations like `@NotNull`, etc.)         |
          | `@Validated` | `org.springframework.validation.annotation.Validated` | Class level or method parameters | ‚úÖ Yes          | For advanced validation (especially when you want *grouped validations*) |
        - üß† @Validated ‚Äì Spring‚Äôs Enhanced Validator (Advanced stuff)
            Supports:
              Validation Groups (like different rules for Create vs Update)
              Method-level validation (like on @Service or @Component)
  6. REST (Representational State Transfer)
      REST - 
        - Representational State Transfer
        - It is a software architecture style or a set of guidelines for designing the communication between diffeerent nodes in a netweork
          It's not actually a protocol
          REST promotes simplicity, scalability and performance which is why it is used in Web Applications
      
      HTTP Methods usage as per REST Guidelines:
        | Operation               | HTTP Method    | Used In Practice? | DTO Split? | Notes                                         |
        | ----------------------- | -------------- | ----------------- | ---------- | --------------------------------------------- |
        | **Create new entity**   | `POST`         | ‚úÖ Yes             | ‚úÖ Yes      | `/users` with CreateUserDTO                   |
        | **Full replace entity** | `PUT`          | üö´ Rarely         | üö´ No      | Not used unless you're replacing *everything* |
        | **Partial update**      | `PATCH`        | ‚úÖ Preferred       | ‚úÖ Yes      | Cleanest way to update fields                 |
        | **Delete**              | `DELETE`       | ‚úÖ Yes             | ‚ùå No       | `/users/{id}`                                 |
        | **Update with POST**    | `POST /update` | ü§è Sometimes      | ‚úÖ Yes      | Pragmatic choice for simple apps              |
        | **Use only `POST`**     | ‚ùå Anti-pattern | ‚ùå Bad idea        | ‚ùå No       | Violates REST principles                      |

      Stateless and Stateful Apps:
        |    | Stateful                                     | Stateless                       |
        | -- | -------------------------------------------- | ------------------------------- |
        | üîÅ | Remembers previous requests                  | Treats every request as new     |
        | üß† | Stores data in server memory                 | Stores data in Redis / DB / JWT |
        | ‚öñÔ∏è | Harder to scale horizontally                 | Super easy to scale             |
        | ‚ö†Ô∏è | Requires sticky sessions/load balancer hacks | Load balancer-friendly          |

  
  7. Redis
    - For Redis to work:
      1. We need to add Redis Config to add Serialiser to the template -> in order to generate the response and cache it
      2. Also, the DTOs need to implement Serializable

  8. Concurrency, Multi-Threading, Locking

      | Area                   | Meaning in Human Words                           | Why It Matters in Backend                               |
      | ---------------------- | ------------------------------------------------ | ------------------------------------------------------- |
      | **Multithreading**     | Running multiple operations at once              | Async processing, non-blocking I/O                      |
      | **Concurrency**        | Managing shared resources across threads safely  | Avoiding bugs when multiple users hit the same resource |
      | **Synchronization**    | Making sure shared data doesn‚Äôt go corrupt       | Updating product stock, cart ops                        |
      | **Thread Safety**      | Designing code that won‚Äôt explode under pressure | Resilient backend logic                                 |
      | **Parallelism**        | Speeding up tasks by dividing across cores       | Processing big data, bulk ops                           |
      | **Thread Pooling**     | Reusing threads efficiently                      | Performance optimization                                |
      | **Locks & Semaphores** | Preventing race conditions and deadlocks         | Inventory, session control                              |

      8.1. MultiThreading:
        8.1.1. Core Java Multithreading:
            - Definition: brain-bytes repo - Run multiple tasks at once using threads
            - Thread: 
              - Process:
                  A independent Program in exceution
                  Has it's own resources, memory and execution context
                  Managed by OS
              - Thread: A light-weight sub-process
                  Has it's own: stack, local variables, program counter
                  Shares: heap, static fields, class level variables
                  Why: To do multiple things at once

                | Feature       | Process                      | Thread                                                   |
                | ------------- | ---------------------------- | -------------------------------------------------------- |
                | Memory        | Own memory space             | Shared memory (within same process)                      |
                | Communication | Expensive (needs IPC)        | Easy (shared variables)                                  |
                | Crash impact  | One process crash = isolated | One thread crash = can kill whole process if not handled |
                | Creation cost | Heavy                        | Lightweight                                              |
                | Example       | Spring Boot app              | HTTP request handler inside the app                      |

                Can be done created in 2 ways:
                  1. Using Thread class
                  2. Runnable Interface
                  -> This is not directly used in Spring boot applications. 
                  -> The above is just raw Java
                  -> Now we will move to better thread handling:
                     - @Async and ExecutorService (uses the above concepts under the hood)

                  | Concept    | Description                                                                                                                                    |
                  | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
                  | `Thread`   | A Java class that represents an actual thread of execution. You can `extend Thread` and override `run()`. Rarely used directly in modern apps. |
                  | `Runnable` | A functional interface with a `run()` method. Commonly used for tasks that **don‚Äôt return a value**.                                           |
                  | `Callable` | Like `Runnable`, but with superpowers: has a `call()` method that **returns a value** and can throw exceptions. Used with `ExecutorService`.   |
                
                üîÑ Thread Lifecycle (start, join, etc.)
                  | Method      | What It Does                                                                                            |
                  | ----------- | ------------------------------------------------------------------------------------------------------- |
                  | `start()`   | Spawns a new thread and calls `run()` inside it.                                                        |
                  | `run()`     | Contains the actual task logic. If you call `run()` directly, no new thread is created!                 |
                  | `join()`    | Makes current thread wait until another thread is done. Think: "Wait till you're done, then I‚Äôll move." |
                  | `sleep(ms)` | Puts the thread to sleep (pauses it) for a bit.                                                         |
                  
                  Also -> stop() -> Depreciated and dangerous
                    -> Leaves the shared resources in a inconsistent state
                    -> doesn‚Äôt release locks properly
                    -> can corrupt memory or data
                    -> alternative is interrrupt()
                        -> why it is safe?
                          -> it doesn't force stop anything, just sets a flag that this thread has to be removed
                          -> Now, it is our job to check for that flag and then handle it in out code and exit if needed.


                üëª Daemon vs User Threads
                  | Type              | Use Case                                                 | Behavior                                    |
                  | ----------------- | -------------------------------------------------------- | ------------------------------------------- |
                  | **User Thread**   | Main app work (e.g., processing payments, saving data)   | Keeps the JVM alive until done              |
                  | **Daemon Thread** | Background tasks (e.g., garbage collection, log cleanup) | JVM exits when only daemon threads are left |

        8.1.2. Java Concurrency API ‚Äì Real World Edition 
          * ExecutorService and ThreadPoolExecutor:
            Why?
              - A better to manage threads
                - No manual creation of threads, We can re-use threads, and we can control the pool size, also queue the tasks as per need
              - 


    9. Elasticsearch (ELK) -> Elasticsearch Logstash Kibana
      9.1. ElasticSearch (ES)
         * Elasticsearch:
          - It is a distributed, JSON-based RESTful Search Engine
          - Elasticsearch is a distributed search and analytics engine that stores data in a way similar to a NoSQL database.
          - While Elasticsearch isn't a traditional relational DB, it does store data in a document-based structure (JSON docs), and it supports fast read/write operations. It's best viewed as a search-first NoSQL datastore ‚Äî optimized for querying and text analysis rather than relational integrity.
          - Elasticsearch uses Apache Lucene, which is the actual full-text search library.
          - Uses:
            - Full Text, Fuzzy Search, Plus Auto-Complete (Product Search)
            - Filtering -> Structured + Keyword Search
            - Sorted Search (to find the trending Users / Products)
            - Log Aggregation and Analytics with Kibana (View and Search Terms)

         * Macbook Installation steps:
            brew install elastic/tap/elasticsearch-full
            brew services start elasticsearch
            elasticsearch

            -- The above approach had some issue in Mac. 
            So, Run with docker ->
              docker run -d --name elasticsearch \
                -p 9200:9200 -p 9300:9300 \
                -e "discovery.type=single-node" \
                docker.elastic.co/elasticsearch/elasticsearch:8.13.4
              To see it running: docker ps
              Auto-Password generation will not be possible as it is not linked to any particular terminal. To reset it:
                docker exec -it elasticsearch /bin/bash
                bin/elasticsearch-reset-password -u elastic
              Alternative: Mount and run it: Persists Reboots and also no password:
                docker run -d --name elasticsearch \
                  -p 9200:9200 -p 9300:9300 \
                  -e "discovery.type=single-node" \
                  -e "xpack.security.enabled=false" \
                  -e "xpack.security.transport.ssl.enabled=false" \
                  -e "ES_JAVA_OPTS=-Xms512m -Xmx512m" \
                  -v esdata:/usr/share/elasticsearch/data \
                  docker.elastic.co/elasticsearch/elasticsearch:8.13.4

         
         * Core Concepts of ElasticSearch:
           - index -> It is like a database-table, one per entity type - Eg. Products
           - document -> A JSON Record -> Like a record in a table
           - field -> A key in our JSON document
           - shard -> It is the logical slice of a index, which is used for scalability
           - replica -> it is the copy of the shard which is used for fault tolerance
           - analyser -> breaks the text into searchable tokens
           - mapping -> Schema definition for documents - defines the field types and the analyzers
           - query -> to find stuffs in Elasticsearch - using match term etc.
          
         * Querying in ElasticSearch:
            - Spring-ElasticSearch Notes:
              - searchSimilar() used more_like_this query under the hood.

            1. Custom Queries via NativeSearchQueryBuilder + ElasticsearchOperations
              This is the go-to.
              Gives full control over queries (match, bool, fuzzy, range, nested ‚Äî the whole ES buffet üç±).
              Works best when building search APIs like product search, filters, faceted search.

            2. Query Derivation (findByNameContaining)
              Fine for simple search boxes, POCs, internal tools.
              Doesn‚Äôt scale well for complex search scenarios.
              Falls apart when you want sorting, pagination, fuzziness, etc.

            3. Autocomplete / Suggesters / Fuzzy Matching
              For modern search (think Amazon/Flipkart search bars), custom analyzers, autocomplete with edge n-grams, and fuzzy matching are used.
              Often set up with custom mappings at index creation.
              Sometimes paired with Redis cache for hot terms.

              | Goal                             | What to Use                                           |
              | -------------------------------- | ----------------------------------------------------- |
              | Simple search by name            | `findByNameContaining()` (for now)                    |
              | Filter + search + sort products  | `NativeSearchQueryBuilder`                            |
              | Advanced: type-ahead suggestions | Custom analyzers + edge n-grams                       |
              | Related products                 | ML + vector search (or fallback to `searchSimilar()`) |

              Intital target for TrendKart:
                - NativeSearchQueryBuilder and CustomAnalysers with edge n-grams (for type-ahead sugestions)
                    You master these two, you can build everything from:

                    * üîç Keyword search
                    * üéØ Filtered search
                    * üîÄ Sorted results (by price, rating, etc.)
                    * ‚ú® Autocomplete suggestions
                    * üòé Fuzzy ‚ÄúDid you mean?‚Äù matches
                    * üìà Faceted navigation (like category filters)
                    * üßÆ Pagination & scroll

                    ### ‚úÖ 1. `NativeSearchQueryBuilder`: Your search godmode
                      We can:

                      * `must`, `should`, `filter` ‚Üí like SQL + AND/OR
                      * Add `sorts` ‚Üí price, rating, etc.
                      * Set `pageable` ‚Üí pagination
                      * Add fuzziness ‚Üí typo-tolerance
                      * Highlight ‚Üí to show matching terms

                      Basically write *structured ES queries* in Java.
                      Much more scalable, readable, and testable than magic `findBy...` methods.

                      ---

                    ### ‚úÖ 2. `Custom Analyzers` + edge n-grams: Your autocomplete power booster
                      We can define **how the data is broken into tokens**, stored, and queried.

                      With:

                      ```json
                      "edge_ngram": {
                        "min_gram": 2,
                        "max_gram": 10,
                        "token_chars": ["letter", "digit"]
                      }
                      ```

                      You can start typing `iph` and BOOM ‚Äî get `iPhone 14 Pro Max` in results.

                      Perfect for:

                      * Type-ahead search bars
                      * Instant suggestions (like Amazon's üîç dropdown)
                      * Fuzzy matches (fixing spelling mistakes)

                    ---

                    | What                       | Why it rules                                    |
                    | -------------------------- | ----------------------------------------------- |
                    | `NativeSearchQueryBuilder` | Fine-grained, powerful, production-friendly     |
                    | `Custom analyzers`         | Gives you autocomplete, spellcheck, fast search |

                    mappings.json - sample
                    {
                      "properties": {
                          "id": {
                              "type": "keyword"
                          },
                          "name": {
                              "type": "text", // Text type for full-text search - meaning it will be analyzed - to search inside that
                              "analyzer": "standard",
                              "search_analyzer": "standard"
                          },
                          "code": {
                              "type": "keyword"
                          },
                          "description": {
                              "type": "text",
                              "analyzer": "standard",
                              "search_analyzer": "standard"
                          },
                          "price": {
                              "type": "float"
                          },
                          "category": {
                              "type": "keyword" // Keyword type for exact matches - to filter or sort by category
                          },
                          "brand": {
                              "type": "keyword" // Keyword type for exact matches - to filter or sort by category
                          },
                          "tags": {
                              "type": "keyword" // Keyword type for exact matches - to filter or sort by category
                          }
                      }
                  }

                  settings.json - 
                  
                  Attributes in FuzzyQuery:
                    üîπ fuzziness:
                        Edit distance allowed between query term and matching term.
                        | Value    | Meaning                                  |
                        | -------- | ---------------------------------------- |
                        | `"0"`    | Exact match only (aka... no fuzz at all) |
                        | `"1"`    | One character difference allowed         |
                        | `"2"`    | Two character differences allowed        |
                        | `"AUTO"` | Smart mode:                              |
                        |          | ‚Üí `length < 3` ‚áí 0                       |
                        |          | ‚Üí `3 <= length <= 5` ‚áí 1                 |
                        |          | ‚Üí `length > 5` ‚áí 2                       |

                    üîπ prefixLength
                        Minimum number of characters at the start that must match exactly.
                        | Value       | Meaning                                  |
                        | ----------- | ---------------------------------------- |
                        | `0`         | No prefix required (fuzz the whole word) |
                        | `1` or more | Require first `n` characters to match    |

                    üîπ maxExpansions
                        How many "similar terms" Elasticsearch will explore during fuzzy matching.
                        | Value       | Meaning                                  |
                        | ----------- | ---------------------------------------- |
                        | `1 - 1000+` | More = better match chance, slower speed |
                     üî• must vs should ‚Äì The Quick Story:
                        | Clause Type | What it means                                                             | Docs must match?                                |
                        | ----------- | ------------------------------------------------------------------------- | ----------------------------------------------- |
                        | `must`      | **AND** logic ‚Äî conditions that MUST match.                               | ‚úÖ Yes                                           |
                        | `should`    | **OR** logic ‚Äî boosts score if matched, or becomes required if no `must`. | ‚ùå Optional (unless `minimumShouldMatch` is set) |


                        Delete all docs in an index - 
                            curl -X POST "localhost:9200/products/_delete_by_query" -H 'Content-Type: application/json' -d'
                            {
                              "query": {
                                "match_all": {}
                              }
                            }'
                        
                        Note: 
                          üí• Problem: Fuzzy search works best with simple or whitespace analyzers (not standard), because standard splits on special characters and normalizes heavily.
                        | Feature         | Autocomplete                                | Fuzzy                              |
                        | --------------- | ------------------------------------------- | ---------------------------------- |
                        | üîç Use Case     | Typing slowly, matching from start          | User types wrong (typos/misspells) |
                        | üß† How it works | Uses `edge_ngram` to pre-index all prefixes | Uses **Levenshtein edit distance** |
                        | ‚è±Ô∏è Speed        | Very fast (precomputed)                     | Slower (calculates at query time)  |
                        | üß™ Example      | "blu" ‚Üí "Bluetooth", "Blues"                | "blutoth" ‚Üí "Bluetooth"            |

          * TO DO LATER -> Search Analytics 
          * ‚ö†Ô∏è Optional Advanced Topics (Not critical unless you're building ES-heavy system):
              | Feature                                                        | Worth Doing?                                          |
              | -------------------------------------------------------------- | ----------------------------------------------------- |
              | **Synonym Graphs** (runtime synonyms)                          | Only if you want dynamic synonyms via plugins         |
              | **Relevance Tuning** (boosting fields)                         | Only for high-scale search optimization               |
              | **Custom scoring**                                             | When you're building recommendation systems           |
              | **Multi-field analyzers** (e.g. `name.standard`, `name.ngram`) | If you want to combine exact, prefix & fuzzy together |
              | **Highlighting**                                               | To highlight matched text in UI                       |
              | **Aggregations** (for facets like "filter by brand")           | Could be cool, but not urgent                         |
              | **Security** (role-based access to indices)                    | Not needed in your app right now                      |

            
      9.2. Kibana
        - It is used to visualise the data from elasticsearch, but never write to it
        Think of it as:
          üìä Frontend for Elasticsearch
          üîç Query playground (like Postman for ES)
          üìà Dashboard builder
          üîê Access control & observability layer
          You don't use Kibana in your Spring Boot app directly ‚Äî it‚Äôs a tool you open in browser (usually runs at localhost:5601).

          | Use Case                                | Why It‚Äôs Useful               |
          | --------------------------------------- | ----------------------------- |
          | üîç Try out queries before coding them   | Dev-friendly                  |
          | üìà Visualize search analytics           | Like what users are searching |
          | üìÇ Explore your indexed documents       | No code needed                |
          | üõ†Ô∏è Manage indices, mappings, analyzers | GUI-style                     |
          | üö¶Monitor ES cluster health & logs      | If going production           |
          | üîÑ Define index lifecycle & rollovers   | For scaling                   |
        
        Steps:
          -> First run elasticsearch
          -> Pull the docker image and run:
            docker run -d \
            --name kibana \
            --link elasticsearch:elasticsearch \
            --restart unless-stopped \
            -p 5601:5601 \
            kibana:8.10.4

            Docker üîÑ Restart Policies Explained:
              | Flag             | Behavior                                                 |
              | ---------------- | -------------------------------------------------------- |
              | `no`             | (default) Never restarts                                 |
              | `on-failure`     | Restarts *only if* exit code ‚â† 0                         |
              | `always`         | Restarts no matter what                                  |
              | `unless-stopped` | Restarts *unless* you explicitly stop it (`docker stop`) |

              So with --restart unless-stopped, your Kibana will:
                Survive reboots
                Auto-recover from crashes
                Only stop if you tell it to
            
            TO DO: Check How to use Kibana

    10. Kafka
        - Scalable, Distributed, Event Streaming Platform.
        - Written in: Java + Scala
        - Spring Boot + Spring Kafka

        üìú Roadmap: Java + Kafka Topics
    
    11. How to make system scalable?

















